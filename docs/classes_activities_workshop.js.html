

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Factotum Documentation classes/activities/workshop.js</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="jsdoc-styles.css">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
             
                <a href="index.html">
                    <h1 class="navbar-item">Factotum Discord Bot Documentation</h1>
                </a>
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    API Documentation
                </a>
                
                 
                    
                        <a
                            class="link user-link "
                            href="https://github.com/nwplus/Factotum"
                        >
                            Github
                        </a>
                    
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
                <div class="search-wrapper">
                    <input id="search" type="text" placeholder="Search docs..." class="input">
                </div>
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Modules</h3><ul><li><a href="module-DiscordServices.html">DiscordServices</a></li><li><a href="module-FirebaseParser.html">FirebaseParser</a></li><li><a href="module-FirebaseServices.html">FirebaseServices</a></li><li><a href="module-MainApp.html">MainApp</a></li><li><a href="module-MongoUtil.html">MongoUtil</a></li></ul><h3>Classes</h3><ul><li><a href="Activity.html">Activity</a></li><li><a href="BotGuild.html">BotGuild</a></li><li><a href="Cave.html">Cave</a></li><li><a href="ChangePreFix.html">ChangePreFix</a></li><li><a href="CoffeeChats.html">CoffeeChats</a></li><li><a href="Console.html">Console</a></li><li><a href="Feature.html">Feature</a></li><li><a href="PermissionCommand.html">PermissionCommand</a></li><li><a href="Room.html">Room</a></li><li><a href="StampsManager.html">StampsManager</a></li><li><a href="Team.html">Team</a></li><li><a href="TeamFormation.html">TeamFormation</a></li><li><a href="Ticket.html">Ticket</a></li><li><a href="TicketManager.html">TicketManager</a></li><li><a href="Verification.html">Verification</a></li><li><a href="Workshop.html">Workshop</a></li></ul><h3><a href="global.html">Global</a></h3></div><div class="category"><h2>Commands</h2><h3>Classes / Verification</h3><ul><li><a href="AddMembers.html">AddMembers</a></li><li><a href="Attend.html">Attend</a></li><li><a href="CheckMember.html">CheckMember</a></li><li><a href="ManualVerify.html">ManualVerify</a></li><li><a href="StartAttend.html">StartAttend</a></li><li><a href="StartVerification.html">StartVerification</a></li><li><a href="Verify.html">Verify</a></li></ul><h3>Classes / Hacker-Utility</h3><ul><li><a href="AskQuestion.html">AskQuestion</a></li><li><a href="Report.html">Report</a></li></ul><h3>Classes / Stamps</h3><ul><li><a href="ChangeStampTime.html">ChangeStampTime</a></li><li><a href="PasswordStamp.html">PasswordStamp</a></li><li><a href="Raffle.html">Raffle</a></li></ul><h3>Classes / Admin-Utility</h3><ul><li><a href="ClearChat.html">ClearChat</a></li><li><a href="Pronouns.html">Pronouns</a></li><li><a href="RoleSelector.html">RoleSelector</a></li><li><a href="SelfCareReminders.html">SelfCareReminders</a></li></ul><h3>Classes / Activity</h3><ul><li><a href="DiscordContests.html">DiscordContests</a></li><li><a href="NewActivity.html">NewActivity</a></li><li><a href="NewCoffeeChats.html">NewCoffeeChats</a></li><li><a href="NewWorkshop.html">NewWorkshop</a></li></ul><h3>Classes / Boothing</h3><ul><li><a href="ERoomDirectory.html">ERoomDirectory</a></li></ul><h3>Classes / Essentials</h3><ul><li><a href="Help.html">Help</a></li><li><a href="InitBot.html">InitBot</a></li><li><a href="UnknownCommand.html">UnknownCommand</a></li></ul><h3>Classes / Start-Commands</h3><ul><li><a href="StartChannelCreation.html">StartChannelCreation</a></li><li><a href="StartMentorCave.html">StartMentorCave</a></li><li><a href="StartTeamFormation.html">StartTeamFormation</a></li><li><a href="StartTeamRoulette.html">StartTeamRoulette</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>classes/activities/workshop.js</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const { Role, Collection, TextChannel, VoiceChannel, GuildCreateChannelOptions, MessageEmbed, Message } = require('discord.js');
const winston = require('winston');
const { randomColor, sendMessageToMember, sendMsgToChannel } = require('../../discord-services');
const Console = require('../consoles/console');
const Room = require('../room');
const TicketManager = require('../tickets/ticket-manager');
const Activity = require('./activity');
const { StringPrompt, SpecialPrompt, ListPrompt } = require('advanced-discord.js-prompts');


/**
 * @typedef PollInfo
 * @property {String} type
 * @property {String} title
 * @property {String} question
 * @property {String} emojiName - must be unicode emoji!
 * @property {Collection&lt;String, String>} responses - &lt;Emoji String, Description>
 */

/**
 * A workshop is an activity with a TA system to help users with questions.
 * The TA system has two options, regular or advanced. Regular option involves TAs reaching out via DMs to users while advanced option 
 * involves users joining a voice channel to receive help. The advanced option is only recommended with knowledgeable discord users.
 * It also has polls the TAs can send to learn basic knowledge from the audience.
 * @extends Activity
 */
class Workshop extends Activity {

    /**
     * 
     * @constructor
     * @param {Activity.ActivityInfo} 
     * @param {Boolean} [isLowTechSolution=true]
     * @param {Collection&lt;String, Role>} [TARoles] - roles with TA permissions
     */
    constructor({activityName, guild, roleParticipants, botGuild}, isLowTechSolution = true, TARoles) {
        super({activityName, guild, roleParticipants, botGuild});

        /**
         * @type {Collection&lt;String, Role>} - roles with TA permissions
         */
        this.TARoles = TARoles || new Collection();

        /**
         * True if the assistance protocol is low tech.
         * @type {Boolean}
         */
        this.isLowTechSolution = isLowTechSolution;

        /**
         * The channel where hackers can ask questions.
         * @type {TextChannel}
         */
        this.assistanceChannel;

        /**
         * The channels only available to TAs
         * @type {Collection&lt;String, TextChannel | VoiceChannel>} - &lt;Channel Name, channel>
         */
        this.TAChannels = new Collection();

        /**
         * TA Console where assistance calls are sent.
         * @type {TextChannel}
         */
        this.TAConsole;

        /**
         * The message where we show the wait list live.
         * @type {Message}
         */
        this.waitListEmbedMsg;

        /**
         * wait list Collection
         * @type {Collection&lt;String, String>} - &lt;User Id, Username>
         */
        this.waitlist = new Collection();

        /**
         * The polls available.
         * @type {Collection&lt;String, PollInfo>} - &lt;Poll type, PollInfo>
         */
        this.polls = new Collection;

        /**
         * The ticket manager.
         * @type {TicketManager}
         */
        this.ticketManager;
    }


    /**
     * Initializes the workshop and adds the ta console, ta banter and assistance channel.
     * @override
     */
    async init() {
        await super.init();

        this.TAConsole = await this.addTAChannel('_üßëüèΩ‚Äçüè´ta-console', {
            type: 'text',
            topic: 'The TA console, here TAs can chat, communicate with the workshop lead, look at the wait list, and send polls!',
        }, [], true);

        this.addTAChannel('_ta-banter', {
            topic: 'For TAs to talk without cluttering the console.',
        });

        this.assistanceChannel = await this.room.addRoomChannel({
            name: 'üôãüèΩassistance', 
            info: {
                type: 'text',
                topic: 'For hackers to request help from TAs for this workshop, please don\'t send any other messages!'
            },
            isSafe: true,
        });

        this.botGuild.blackList.set(this.assistanceChannel.id, 3000);
        this.botGuild.save();

        if (this.isLowTechSolution) {
            this.ticketManager = new TicketManager(this, {
                ticketCreatorInfo: {
                    channel: this.assistanceChannel,
                },
                ticketDispatcherInfo: {
                    channel: await this.room.addRoomChannel({
                        name: '_Incoming Tickets',
                        isSafe: true,
                    }),
                    takeTicketEmoji: 'üëç',
                    joinTicketEmoji: '‚òùÔ∏è',
                    reminderInfo: {
                        isEnabled: true,
                        time: 5
                    },
                    mainHelperInfo: {
                        role: this.TARoles.first(),
                        emoji: '‚úã',
                    },
                    embedCreator: (ticket) => new MessageEmbed()
                        .setTitle(`New Ticket - ${ticket.id}`)
                        .setDescription(`&lt;@${ticket.group.first().id}> has a question: ${ticket.question}`)
                        .setTimestamp(),
                },
                systemWideTicketInfo: {
                    garbageCollectorInfo: {
                        isEnabled: false,
                    },
                    isAdvancedMode: false,
                }
            }, this.guild, this.botGuild);
        }

        winston.loggers.get(this.guild.id).event(`The activity ${this.name} was transformed to a workshop.`, {event: 'Activity'});

        return this;
    }


    /**
     * Adds extra workshop features, plus the regular features. Also adds default polls.
     * @override
     */
    addDefaultFeatures() {
        this.addDefaultPolls();

        /** @type {Console.Feature[]} */
        let localFeatures = [];

        this.polls.forEach((pollInfo) => localFeatures.push({
            name: pollInfo.title,
            description: `Asks the question: ${pollInfo.title} - ${pollInfo.question}`,
            emojiName: pollInfo.emojiName,
            callback: (user, reaction, stopInteracting, console) => this.sendPoll(pollInfo.type).then(() => stopInteracting()),
        }));

        localFeatures.forEach(feature => this.adminConsole.addFeature(feature));

        super.addDefaultFeatures();
    }


    /**
     * Adds the default polls to the polls list.
     * @protected
     */
    addDefaultPolls() {
        /** @type {PollInfo[]} */
        let localPolls = [
            {
                title: 'Speed Poll!',
                type: 'Speed Poll',
                emojiName: 'üèéÔ∏è',
                question: 'Please react to this poll!',
                responses: new Collection([['üê¢', 'Too Slow?'], ['üê∂', 'Just Right?'], ['üêá', 'Too Fast?']]),
            },
            {
                title: 'Difficulty Poll!',
                type: 'Difficulty Poll',
                emojiName: '‚úçÔ∏è',
                question: 'Please react to this poll! If you need help, go to the assistance channel!',
                responses: new Collection([['üê¢', 'Too Hard?'], ['üê∂', 'Just Right?'], ['üêá', 'Too Easy?']]),
            },
            {
                title: 'Explanation Poll!',
                type: 'Explanation Poll',
                emojiName: 'üßë‚Äçüè´',
                question: 'Please react to this poll!',
                responses: new Collection([['üê¢', 'Hard to understand?'], ['üê∂', 'Meh explanations?'], ['üêá', 'Easy to understand?']]),
            }
        ];

        localPolls.forEach(pollInfo => this.polls.set(pollInfo.type, pollInfo));
    }
    

    /**
     * Will send all the consoles the workshop needs to work.
     * @async
     */
    async sendConsoles() {
        let mentorColor = randomColor();

        const TAInfoEmbed = new MessageEmbed()
            .setTitle('TA Information')
            .setDescription('Please read this before the workshop starts!')
            .setColor(mentorColor);
        this.isLowTechSolution ? TAInfoEmbed.addField('Ticketing System is turned on!', `* Tickets will be sent to &lt;#${this.ticketManager.ticketDispatcherInfo.channel.id}>
            \n* React to the ticket message and send the user a DM by clicking on their name`) :
            TAInfoEmbed.addField('Advanced Voice Channel System is turned on!', `* Users who need help will be listed in a message on channel &lt;#${this.TAConsole}>
                \n* Users must be on the general voice channel to receive assistance
                \n* You must be on a private voice channel to give assistance
                \n* When you react to the message, the user will be moved to your voice channel so you can give assistance
                \n* Once you are done, move the user back to the general voice channel`);
        this.TAConsole.send(TAInfoEmbed);

        // Console for TAs to send polls and stamp distribution
        let TAPollingConsole = new Console({
            title: 'Polling and Stamp Console',
            description: 'Here are some common polls you might want to use!',
            channel: this.TAConsole,
            guild: this.guild,
        });
        this.polls.forEach((pollInfo) => TAPollingConsole.addFeature({
            name: pollInfo.title,
            description: `Asks the question: ${pollInfo.title} - ${pollInfo.question}`,
            emojiName: pollInfo.emojiName,
            callback: (user, reaction, stopInteracting, console) => this.sendPoll(pollInfo.type).then(() => stopInteracting()),
        }));
        TAPollingConsole.addFeature({
            name: 'Stamp Distribution',
            description: 'Activate a stamp distribution on the activity\'s text channel',
            emojiName: 'üìá',
            callback: (user, reaction, stopInteracting, console) => {
                this.distributeStamp(this.room.channels.generalText);
                stopInteracting();
            }
        });
        TAPollingConsole.sendConsole();

        if (this.isLowTechSolution) {
            await this.ticketManager.sendTicketCreatorConsole('Get some help from the Workshop TAs!', 
                'React to this message with the emoji and write a quick description of your question. A TA will reach out via DM soon.');
            this.ticketManager.ticketCreatorInfo.console.addField('Simple or Theoretical Questions', 'If you have simple or theory questions, ask them in the main banter channel!');
        } else {
            // embed message for TA console
            const incomingTicketsEmbed = new MessageEmbed()
                .setColor(mentorColor)
                .setTitle('Hackers in need of help waitlist')
                .setDescription('* Make sure you are on a private voice channel not the general voice channel \n* To get the next hacker that needs help click ü§ù');
            this.TAConsole.send(incomingTicketsEmbed).then(message => this.incomingTicketsHandler(message));

            // where users can request assistance
            const outgoingTicketEmbed = new MessageEmbed()
                .setColor(this.botGuild.colors.embedColor)
                .setTitle(this.name + ' Help Desk')
                .setDescription('Welcome to the ' + this.name + ' help desk. There are two ways to get help explained below:')
                .addField('Simple or Theoretical Questions', 'If you have simple or theory questions, ask them in the main banter channel!')
                .addField('Advanced Question or Code Assistance', 'If you have a more advanced question, or need code assistance, click the üßëüèΩ‚Äçüè´ emoji for live TA assistance! Join the ' +  this.room.channels.generalVoice.name || Room.voiceChannelName + ' voice channel if not already there!');
            this.assistanceChannel.send(outgoingTicketEmbed).then(message => this.outgoingTicketHandler(message));
        }
    }


    /**
     * Adds a channel to the activity, ask if it will be for TAs or not.
     * @param {TextChannel} channel - channel to prompt user
     * @param {String} userId - user to prompt for channel info
     * @override
     */
    async addChannel(channel, userId) {
        // ask if it will be for TA
        let isTa = await SpecialPrompt.boolean({ prompt: 'Is this channel for TAs?', channel, userId });

        if (isTa) {
            /** @type {TextChannel} */
            let newChannel = await super.addChannel(channel, userId);
            this.getTAChannelPermissions().forEach(rolePermission => newChannel.updateOverwrite(rolePermission.id, rolePermission.permissions));
            this.TAChannels.set(newChannel.name, newChannel);
        } else {
            super.addChannel(channel, userId);
        }
    }


    /**
     * Creates a channel only available to TAs.
     * @param {String} name 
     * @param {GuildCreateChannelOptions} info
     * @returns {Promise&lt;TextChannel | VoiceChannel>}
     * @async 
     */
    async addTAChannel(name, info) {
        let channel = await this.room.addRoomChannel({name, info, permissions: this.getTAChannelPermissions()});
        this.TAChannels.set(channel.name, channel);
        return channel;
    }


    /**
     * Returns the perms for a TA Channel
     * @protected
     * @returns {Activity.RolePermission[]}
     */
    getTAChannelPermissions() {
        /** The permissions for the TA channels */
        let TAChannelPermissions = [
            { id: this.botGuild.roleIDs.everyoneRole, permissions: { VIEW_CHANNEL: false } },
        ];

        // add regular activity members to the TA perms list as non tas, so they cant see that channel
        this.room.rolesAllowed.forEach(role => {
            TAChannelPermissions.push({id: role.id, permissions: {VIEW_CHANNEL: false}});

        });

        // Loop over ta roles, give them voice channel perms and add them to the TA permissions list
        this.TARoles.forEach(role => {
            TAChannelPermissions.push({id: role.id, permissions: {VIEW_CHANNEL: true}});
        });

        return TAChannelPermissions;
    }


    /**
     * FEATURES:
     */


    /**
     * Send a poll to the general text channel
     * @param {String} type - the type of poll to send
     * @async
     */
    async sendPoll(type, channel, userId) {
        let poll = this.polls.get(type);
        if (!poll) throw new Error('No poll was found of that type!');
        
        // create poll
        let description = poll.question + '\n\n';
        for (const key of poll.responses.keys()) {
            description += '**' + poll.responses.get(key) + '->** ' + key + '\n\n';
        }

        let qEmbed = new MessageEmbed()
            .setColor(this.botGuild.colors.embedColor)
            .setTitle(poll.title)
            .setDescription(description);

        // send poll to general text or prompt for channel
        let pollChannel;
        if ((await this.room.channels.generalText.fetch(true))) pollChannel = this.room.channels.generalText;
        else pollChannel = ListPrompt.singleListChooser({
            prompt: 'What channel should the poll go to?',
            channel: channel,
            userId: userId
        }, this.room.channels.textChannels.array());

        pollChannel.send(qEmbed).then(msg => {
            poll.responses.forEach((value, key) => msg.react(key));
        });

        winston.loggers.get(this.guild.id).event(`Activity named ${this.name} sent a poll with title: ${poll.title} and question ${poll.question}.`, { event: 'Workshop' });
    }

    /**
     * Creates and handles with the emoji reactions on the incoming ticket console embed
     * @param {Message} message 
     */
    incomingTicketsHandler(message) {
        message.pin();
        message.react('ü§ù');

        this.waitListEmbedMsg = message;

        // add reaction to get next in this message!
        const getNextCollector = message.createReactionCollector((reaction, user) => !user.bot &amp;&amp; reaction.emoji.name === 'ü§ù');

        getNextCollector.on('collect', async (reaction, user) => {
            // remove the reaction
            reaction.users.remove(user.id);

            // check that there is someone to help
            if (this.waitlist.size === 0) {
                this.TAConsole.send('&lt;@' + user.id + '> No one to help right now!').then(msg => msg.delete({ timeout: 5000 }));
                return;
            }

            // if pullInFunctionality is turned off then then just remove from list
            if (this.isLowTechSolution) {
                // remove hacker from wait list
                let hackerKey = this.waitlist.firstKey();
                this.waitlist.delete(hackerKey);

            } else {
                // grab the ta and their voice channel
                var ta = message.guild.member(user.id);
                var taVoice = ta.voice.channel;

                // check that the ta is in a voice channel
                if (taVoice === null || taVoice === undefined) {
                    this.TAConsole.send('&lt;@' + user.id + '> Please join a voice channel to assist hackers.').then(msg => msg.delete({ timeout: 5000 }));
                    return;
                }

                // get next user
                let hackerKey = this.waitlist.firstKey();
                this.waitlist.delete(hackerKey);
                var hacker = message.guild.member(hackerKey);

                // if status mentor in use there are no hackers in list
                if (hacker === undefined) {
                    this.TAConsole.send('&lt;@' + user.id + '> There are no hackers in need of help!').then(msg => msg.delete({ timeout: 5000 }));
                    return;
                }

                try {
                    await hacker.voice.setChannel(taVoice);
                    sendMessageToMember(hacker, 'TA is ready to help you! You are with them now!', true);
                    this.TAConsole.send('&lt;@' + user.id + '> A hacker was moved to your voice channel! Thanks for your help!!!').then(msg => msg.delete({ timeout: 5000 }));
                } catch (err) {
                    sendMessageToMember(hacker, 'A TA was ready to talk to you, but we were not able to pull you to their voice ' +
                        'voice channel. Try again and make sure you are in the general voice channel!');
                    this.TAConsole.send('&lt;@' + user.id + '> We had someone that needed help, but we were unable to move them to your voice channel. ' +
                        'They have been notified and skipped. Please help someone else!').then(msg => msg.delete({ timeout: 8000 }));
                }
            }

            // remove hacker from the embed list
            this.waitListEmbedMsg.edit(this.waitListEmbedMsg.embeds[0].spliceFields(0, 1));
        });
    }

    /**
     * Creates and handles with the emoji reactions on the outgoing ticket console embed
     * @param {Message} message 
     */
    outgoingTicketHandler(message) {
        message.pin();
        message.react('üßëüèΩ‚Äçüè´');

        // filter collector and event handler for help emoji from hackers
        const helpCollector = message.createReactionCollector((reaction, user) => !user.bot &amp;&amp; reaction.emoji.name === 'üßëüèΩ‚Äçüè´');

        helpCollector.on('collect', async (reaction, user) => {
            // remove the emoji
            reaction.users.remove(user.id);

            // check that the user is not already on the wait list
            if (this.waitlist.has(user.id)) {
                sendMessageToMember(user, 'You are already on the TA wait list! A TA will get to you soon!', true);
                return;
            } else {
                var position = this.waitlist.size;
                // add user to wait list
                this.waitlist.set(user.id, user.username);
            }

            let oneLiner = await StringPrompt.single({prompt: 'Please send to this channel a one-liner of your problem or question. You have 20 seconds to respond', channel: this.assistanceChannel, userId: user.id });

            const hackerEmbed = new MessageEmbed()
                .setColor(this.botGuild.colors.embedColor)
                .setTitle('Hey there! We got you signed up to talk to a TA!')
                .setDescription('You are number: ' + position + ' in the wait list.')
                .addField(!this.isLowTechSolution ? 'JOIN THE VOICE CHANNEL!' : 'KEEP AN EYE ON YOUR DMs', 
                    !this.isLowTechSolution ? 'Sit tight in the voice channel. If you are not in the voice channel when its your turn you will be skipped, and we do not want that to happen!' :
                        'A TA will reach out to you soon via DM! Have your question ready and try to keep up with the workshop until then!');

            sendMessageToMember(user, hackerEmbed);

            // update message embed with new user in list
            this.waitListEmbedMsg.edit(this.waitListEmbedMsg.embeds[0].addField(user.username, '&lt;@' + user.id + '> has the question: ' +  oneLiner));
            
            // send a quick message to let ta know a new user is on the wait list
            this.TAConsole.send('A new hacker needs help!').then(msg => msg.delete({timeout: 3000}));
        });
    }
}

module.exports = Workshop;</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by 
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>

<script src="scripts/search.js"> </script>

</body>
</html>
